# -*- coding: utf-8 -*-
"""load_forecast.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_tgczhz5KXi0lZ85PMni3zK5jflYGo1G
"""

import pandas as pd

from google.colab import drive
drive.mount('/content/drive/')

df=pd.read_csv('/content/drive/MyDrive/train1.csv')

df

df1=df.drop(['MA_X-4','dayOfWeek','weekend','holiday','Holiday_ID','hourOfDay','T2M_toc'],axis=1)

df1.head()

import numpy as np
dataset=df1.to_numpy()

dataset

df2=df1.reset_index()[['week_X-2','week_X-3','week_X-4','DEMAND']]

df2

import numpy as np
from sklearn.preprocessing import MinMaxScaler
scaler=MinMaxScaler(feature_range=(0,1))
df3=scaler.fit_transform(np.array(df2))

df3

df3.shape

training_size=17544
test_size=168
train_data,test_data=df3[0:training_size-1,:],df3[training_size-169:training_size+167,:]

training_size,test_size

train_data.shape,test_data.shape

import numpy as np
def process(arr):
    ini_array1 = np.array(arr)
    result = ini_array1.flatten()
    return result

import numpy 
def createdataset(dataset,timestep=1):
    dataX,dataY=[],[]
    for i in range(len(dataset)-timestep-1):
        a=dataset[i:(i+timestep),:]
        #process to convert 2-d datset to 1-d
        b=process(a)
        dataY.append(dataset[i+timestep,3])
        dataX.append(b)
    return numpy.array(dataX),numpy.array(dataY)

timestep=168
X_train,Y_train=createdataset(train_data,timestep)
X_test,Y_test=createdataset(test_data,timestep)

train_data

X_train.shape,X_test.shape

Y_train.shape,Y_test.shape

from sklearn.svm import SVR
regressor=SVR(kernel='rbf')
regressor.fit(X_train,Y_train)

Y_pred=regressor.predict(X_test)

import matplotlib.pyplot as plt
z=np.arange(1,168,1)
plt.figure(figsize=(25,6))
plt.plot(z, Y_test, color = 'red', linewidth=2.0, alpha = 0.6)
plt.plot(z, Y_pred, color = 'blue', linewidth=0.8)
plt.legend(['Actual','Predicted'])
plt.xlabel('Timestamp')
plt.title("Training data prediction")
plt.show()

Y_pred

Y_test

Y=Y_pred-Y_test

Y

Y.shape

sum(Y)

APE = []
for i in range(len(Y_pred)-1):
    
    # Calculate percentage error
    per_err = (Y_test[i] - Y_pred[i]) / Y_test[i]
  
    # Take absolute value of
    # the percentage error (APE)
    per_err = abs(per_err)
  
    # Append it to the APE list
    APE.append(per_err)
  
# Calculate the MAPE
MAPE = sum(APE)/len(APE)

MAPE

